//See /assets/ts/pathmap.ts for license info.
class ArrayMap{constructor(t=new Map){this.map=t}clear(){return this.map.clear()}delete(t){return this.apply(t,(t,e)=>e.delete(t))}forEach(t,e){throw new Error("Method forEach not implemented.")}get(t){return this.apply(t,(t,e)=>e.get(t))}has(t){return this.apply(t,(t,e)=>e.has(t))}set(t,e){return this.apply(t,(t,r)=>r.set(t,e)),this}get size(){return this.map.size}entries(){return function*(t){for(const[e,r]of t.map.entries())yield[[e],r]}(this)}keys(){return function*(t){for(const e of t.map.keys())yield[e]}(this)}values(){return this.map.values()}[Symbol.iterator](){throw new Error("Iterator not implemented")}static copy(t){return[...t]}resolve(t){return[(t=ArrayMap.copy(t)).pop(),t.reduce(function(e,r,s){let n=e.get([r]);if(void 0===n)e.set([r],n=new ArrayMap);else if(!(n instanceof ArrayMap))throw new Error(`Cannot resolve key ${t.slice(0,s+1)}. "${r}" is not a map.`);return n},this)]}apply(t,e){if(1===t.length)return e(t[0],this.map);{const[r,s]=this.resolve(t);return e([r],s)}}}Symbol.toStringTag;class PathMap{constructor(t=new ArrayMap,e="/"){this.map=t,this.SEPARATOR=e}toParts(t){const e=(()=>Array.isArray(t)?t:(t.startsWith(this.SEPARATOR)&&(t=t.substring(this.SEPARATOR.length)),t.split(this.SEPARATOR)))();if(e.forEach((e,r,s)=>{switch(e){case"":throw new Error(`The part of path "${t}" at "${null!=s[r-1]?s[r-1]+"/":""}<here>${null!=s[r+1]?"/"+s[r+1]:""}" cannot be empty.`);case"..":s.splice(r,2);case".":s.splice(r,1)}}),e.length<=0)throw new Error(`The path "${t}" effectively has no parts.`);return e}toOwn(t){return t instanceof ArrayMap?new PathMap(t,this.SEPARATOR):t}clear(){this.map.clear()}delete(t){return this.map.delete(this.toParts(t))}forEach(t,e){throw new Error("Method forEach not implemented.")}get(t){return this.toOwn(this.map.get(this.toParts(t)))}has(t){return this.map.has(this.toParts(t))}set(t,e){return this.map.set(this.toParts(t),e),this}get size(){return this.map.size}entries(){return function*(t){for(const[e,r]of t.map.entries())yield[e.join(t.SEPARATOR),t.toOwn(r)]}(this)}keys(){return function*(t){for(const e of t.map.keys())yield e.join(t.SEPARATOR)}(this)}values(){return function*(t){for(const e of t.map.values())yield t.toOwn(e)}(this)}[Symbol.iterator](){throw new Error("Iterator not implemented.")}serialize(){return JSON.stringify(this,function(t,e){return e instanceof PathMap?Object.fromEntries([...e.entries()].map(([t,e])=>[t,e instanceof PathMap?e:JSON.stringify(e)])):e})}static deserialize(t,e="/"){return new PathMap(JSON.parse(t,function(t,e){return"object"==typeof e&&null!==e?new ArrayMap(new Map(Object.entries(e))):JSON.parse(e)}),e)}}Symbol.toStringTag;